"""
Integration tests for UnitOfWork pattern.

These tests use a REAL database to validate:
- Actual transaction commit/rollback
- Real session sharing between repositories
- Database-level atomicity
- Concurrent modification handling

Unlike unit tests (which mock the session), integration tests verify
that UnitOfWork works correctly with actual PostgreSQL database.

Test Strategy:
- Use test database (not production)
- Each test runs in isolated transaction
- Cleanup after each test
- Validate actual DB state changes

Related: ADR-002 (UnitOfWork pattern), test_unit_of_work.py (unit tests)
"""

import pytest
from datetime import datetime
from decimal import Decimal
from contextlib import asynccontextmanager

from src.modules.fermentation.src.repository_component.unit_of_work import UnitOfWork
from src.modules.fermentation.src.domain.dtos import FermentationCreate
from src.modules.fermentation.src.domain.enums.fermentation_status import FermentationStatus
from src.modules.fermentation.src.domain.enums.sample_type import SampleType


@pytest.fixture
def session_manager_factory(db_session):
    """
    Create a session manager factory for UnitOfWork.
    
    Uses the same pattern as conftest.py - returns a callable
    that creates context managers for the test session.
    
    Args:
        db_session: Test database session from conftest
    
    Returns:
        Callable that returns async context manager for session
    """
    @asynccontextmanager
    async def get_session():
        """Async context manager that yields the test session."""
        yield db_session
    
    return get_session


@pytest.fixture
def uow(session_manager_factory):
    """
    Create a UnitOfWork instance with test session factory.
    
    Args:
        session_manager_factory: Callable that returns session context manager
    
    Returns:
        UnitOfWork: UnitOfWork instance for integration testing
    """
    return UnitOfWork(session_manager_factory)


class TestUnitOfWorkTransactionCommit:
    """Test that UoW commits actually persist to database."""
    
    @pytest.mark.asyncio
    @pytest.mark.integration
    async def test_commit_persists_fermentation_to_database(self, uow):
        """
        Given: A UoW with a new fermentation created
        When: Calling commit()
        Then: Fermentation should be persisted in database
        
        Validates:
        - Fermentation is written to DB
        - ID is generated by database
        - Data integrity is maintained
        """
        # Arrange
        fermentation_data = FermentationCreate(
            fermented_by_user_id=1,
            vintage_year=2024,
            yeast_strain="Test Yeast",
            vessel_code="V-TEST-001",
            input_mass_kg=Decimal("100.50"),
            initial_sugar_brix=Decimal("22.5"),
            initial_density=Decimal("1.095"),
            start_date=datetime(2024, 11, 15)
        )
        winery_id = 1
        fermentation_id = None
        
        # Act - Create fermentation and commit
        async with uow:
            fermentation = await uow.fermentation_repo.create(
                winery_id=winery_id,
                data=fermentation_data
            )
            fermentation_id = fermentation.id
            await uow.commit()
        
        # Assert - Verify fermentation exists in database
        async with uow:
            retrieved = await uow.fermentation_repo.get_by_id(
                fermentation_id=fermentation_id,
                winery_id=winery_id
            )
            assert retrieved is not None
            assert retrieved.id == fermentation_id
            assert retrieved.vessel_code == "V-TEST-001"
            assert retrieved.status == FermentationStatus.ACTIVE
    
    @pytest.mark.asyncio
    @pytest.mark.integration
    async def test_commit_persists_multiple_operations(self, uow):
        """
        Given: A UoW with fermentation + sample created
        When: Calling commit()
        Then: Both operations should be persisted atomically
        
        Validates:
        - Multiple repo operations in one transaction
        - Atomicity (all or nothing)
        - Cross-repository transaction coordination
        """
        # Arrange
        fermentation_data = FermentationCreate(
            fermented_by_user_id=1,
            vintage_year=2024,
            yeast_strain="Multi-Op Test",
            vessel_code="V-MULTI-001",
            input_mass_kg=Decimal("200.0"),
            initial_sugar_brix=Decimal("24.0"),
            initial_density=Decimal("1.100"),
            start_date=datetime(2024, 11, 15)
        )
        winery_id = 1
        
        # Act - Create fermentation AND sample in same transaction
        async with uow:
            fermentation = await uow.fermentation_repo.create(
                winery_id=winery_id,
                data=fermentation_data
            )
            fermentation_id = fermentation.id
            
            # Create sample for this fermentation
            sample = await uow.sample_repo.create_sample(
                winery_id=winery_id,
                fermentation_id=fermentation_id,
                sample_type=SampleType.SUGAR,
                sample_date=datetime(2024, 11, 16),
                measured_by_user_id=1,
                value=Decimal("20.5")
            )
            sample_id = sample.id
            
            await uow.commit()
        
        # Assert - Both should exist in database
        async with uow:
            retrieved_ferm = await uow.fermentation_repo.get_by_id(
                fermentation_id=fermentation_id,
                winery_id=winery_id
            )
            retrieved_sample = await uow.sample_repo.get_sample_by_id(
                sample_id=sample_id,
                winery_id=winery_id
            )
            
            assert retrieved_ferm is not None
            assert retrieved_sample is not None
            assert retrieved_sample.fermentation_id == fermentation_id


class TestUnitOfWorkTransactionRollback:
    """Test that UoW rollback actually discards changes."""
    
    @pytest.mark.asyncio
    @pytest.mark.integration
    async def test_rollback_discards_fermentation_creation(self, uow):
        """
        Given: A UoW with a new fermentation created
        When: Calling rollback() instead of commit()
        Then: Fermentation should NOT be in database
        
        Validates:
        - Rollback actually discards changes
        - No partial data in database
        - Database remains consistent
        """
        # Arrange
        fermentation_data = FermentationCreate(
            fermented_by_user_id=1,
            vintage_year=2024,
            yeast_strain="Rollback Test",
            vessel_code="V-ROLLBACK-001",
            input_mass_kg=Decimal("100.0"),
            initial_sugar_brix=Decimal("22.0"),
            initial_density=Decimal("1.090"),
            start_date=datetime(2024, 11, 15)
        )
        winery_id = 1
        fermentation_id = None
        
        # Act - Create fermentation but rollback
        async with uow:
            fermentation = await uow.fermentation_repo.create(
                winery_id=winery_id,
                data=fermentation_data
            )
            fermentation_id = fermentation.id
            await uow.rollback()
        
        # Assert - Fermentation should NOT exist in database
        async with uow:
            retrieved = await uow.fermentation_repo.get_by_id(
                fermentation_id=fermentation_id,
                winery_id=winery_id
            )
            assert retrieved is None
    
    @pytest.mark.asyncio
    @pytest.mark.integration
    async def test_auto_rollback_on_exception(self, uow):
        """
        Given: A UoW where exception occurs after creation
        When: Exception is raised before commit
        Then: All changes should be rolled back automatically
        
        Validates:
        - Automatic rollback on exception
        - Transaction safety
        - No orphaned data in database
        """
        # Arrange
        fermentation_data = FermentationCreate(
            fermented_by_user_id=1,
            vintage_year=2024,
            yeast_strain="Exception Test",
            vessel_code="V-EXCEPTION-001",
            input_mass_kg=Decimal("100.0"),
            initial_sugar_brix=Decimal("22.0"),
            initial_density=Decimal("1.090"),
            start_date=datetime(2024, 11, 15)
        )
        winery_id = 1
        fermentation_id = None
        
        # Act - Create fermentation but raise exception
        with pytest.raises(ValueError):
            async with uow:
                fermentation = await uow.fermentation_repo.create(
                    winery_id=winery_id,
                    data=fermentation_data
                )
                fermentation_id = fermentation.id
                raise ValueError("Simulated error")
        
        # Assert - Fermentation should NOT exist (auto-rollback)
        async with uow:
            retrieved = await uow.fermentation_repo.get_by_id(
                fermentation_id=fermentation_id,
                winery_id=winery_id
            )
            assert retrieved is None


class TestUnitOfWorkSessionSharing:
    """Test that repositories share the same session within UoW."""
    
    @pytest.mark.asyncio
    @pytest.mark.integration
    async def test_repos_see_uncommitted_changes(self, uow):
        """
        Given: A UoW with fermentation created (not committed)
        When: Accessing fermentation through another repo query
        Then: Should see the uncommitted fermentation (same session)
        
        Validates:
        - Repositories share same database session
        - Uncommitted changes visible within transaction
        - Proper transaction isolation
        """
        # Arrange
        fermentation_data = FermentationCreate(
            fermented_by_user_id=1,
            vintage_year=2024,
            yeast_strain="Session Share Test",
            vessel_code="V-SESSION-001",
            input_mass_kg=Decimal("100.0"),
            initial_sugar_brix=Decimal("22.0"),
            initial_density=Decimal("1.090"),
            start_date=datetime(2024, 11, 15)
        )
        winery_id = 1
        
        # Act & Assert
        async with uow:
            # Create fermentation
            fermentation = await uow.fermentation_repo.create(
                winery_id=winery_id,
                data=fermentation_data
            )
            fermentation_id = fermentation.id
            
            # Query it back through same UoW (should see it)
            retrieved = await uow.fermentation_repo.get_by_id(
                fermentation_id=fermentation_id,
                winery_id=winery_id
            )
            
            # Within same UoW, should see uncommitted fermentation
            assert retrieved is not None
            assert retrieved.id == fermentation_id
            
            # Don't commit - let it rollback
            await uow.rollback()


class TestUnitOfWorkAtomicity:
    """Test that UoW provides true atomicity (all-or-nothing)."""
    
    @pytest.mark.asyncio
    @pytest.mark.integration
    async def test_partial_failure_rolls_back_all(self, uow):
        """
        Given: A UoW with multiple operations where one fails
        When: Second operation raises error
        Then: First operation should also be rolled back
        
        Validates:
        - True atomicity (all or nothing)
        - No partial state in database
        - Transaction consistency
        """
        # Arrange
        fermentation_data = FermentationCreate(
            fermented_by_user_id=1,
            vintage_year=2024,
            yeast_strain="Atomicity Test",
            vessel_code="V-ATOMIC-001",
            input_mass_kg=Decimal("100.0"),
            initial_sugar_brix=Decimal("22.0"),
            initial_density=Decimal("1.090"),
            start_date=datetime(2024, 11, 15)
        )
        winery_id = 1
        fermentation_id = None
        
        # Act - Create fermentation, then fail on sample creation
        with pytest.raises(Exception):
            async with uow:
                fermentation = await uow.fermentation_repo.create(
                    winery_id=winery_id,
                    data=fermentation_data
                )
                fermentation_id = fermentation.id
                
                # Try to create invalid sample (should fail)
                await uow.sample_repo.create_sample(
                    winery_id=winery_id,
                    fermentation_id=9999999,  # Invalid FK - will fail
                    sample_type=SampleType.SUGAR,
                    sample_date=datetime(2024, 11, 16),
                    measured_by_user_id=1,
                    value=Decimal("20.0")
                )
        
        # Assert - Fermentation should NOT exist (atomicity)
        async with uow:
            retrieved = await uow.fermentation_repo.get_by_id(
                fermentation_id=fermentation_id,
                winery_id=winery_id
            )
            assert retrieved is None
